//
// Created by gortium on 27/04/17.
//
#include <stdio.h>
#include <string>
#include <sstream>
#include "ros/ros.h"
#include "serial/serial.h"
#include <hardware_interface/joint_command_interface.h>
#include <hardware_interface/joint_state_interface.h>
#include <hardware_interface/robot_hw.h>
#include <wm_roboteq_hardware_interface/wm_roboteq_hardware_interface.h>

namespace WMRoboteq
{

  WMRoboteqHardwareInterface::WMRoboteqHardwareInterface()
      : joint_name_({"roboteq_join"}),
        joint_position_{0.0},
        joint_velocity_{0.0},
        joint_effort_{0.0},
        joint_velocity_command_{0.0},
        command_("!", this),
        param_("^", this),
        serial_(),
        query_("?", this)

  {
  }

  bool WMRoboteqHardwareInterface::init(ros::NodeHandle &root_nh, ros::NodeHandle &robot_hw_nh)
  {
    //std::vector <std::string> ports;
    //std::vector <std::string> joints;

    //robot_hw_nh.getParam("joints", joints);

    //joint_name_[0] = joints[0];

    // Connect and register the joint state interface
    joint_state_interface_.registerHandle(
        hardware_interface::JointStateHandle(joint_name_[0], &joint_position_[0], &joint_velocity_[0],
                                             &joint_effort_[0]));

    registerInterface(&joint_state_interface_);

    // Connect and register the joint velocity interface
    joint_velocity_interface_.registerHandle(
        hardware_interface::JointHandle(joint_state_interface_.getHandle(joint_name_[0]), &joint_velocity_command_[0]));

    registerInterface(&joint_velocity_interface_);

//    baud_ = 115200;
//    robot_hw_nh.getParam("ports", ports);
//    robot_hw_nh.getParam("baud", baud_);
//    robot_hw_nh.getParam("id", param_id_);
//
//    // TimeoutCallback
//    timeout_timer_ = nh_.createTimer(ros::Duration(0.1), &WMRoboteqHardwareInterface::timeoutCallback, this);
//    timeout_timer_.stop();
//
//    int i = 0;
//    while (!connected_ && param_id_ == device_id_)
//    {
//      port_ = ports.at(i).c_str();
//      connect();
//      ROS_INFO("POST USED : %s", *port_);
//      sleep(1);
//      getId();
//      if (i++ >= ports.size() - 1) i = 0;
//    }
//
//    ROS_INFO("ID: %i", device_id_);
//
//    // Test connection.
//    if (connected_)
//    {
//      ROS_DEBUG("Connection to %s at %i baud is successful.", *port_, baud_);
//    } else
//    {
//      ROS_DEBUG("Problem connecting to serial device.");
//      ROS_ERROR_STREAM_ONCE("Problem connecting to port " << *port_ << ". Trying again every 1 second.");
//      sleep(1);
//    }
  }

  void WMRoboteqHardwareInterface::connect()
  {
    if (!serial_) serial_ = new serial::Serial();
    serial::Timeout to(serial::Timeout::simpleTimeout(500));
    serial_->setTimeout(to);
    serial_->setPort(port_);
    serial_->setBaudrate(baud_);

    ROS_INFO("PORT: %s", port_);
    ROS_INFO("BAUD: %i", baud_);

    for (int tries = 0; tries < 5; tries++)
    {
      try
      {
        serial_->open();
        query_ << "FID" << send_;
        setSerialEcho(false);
        flush();
      } catch (serial::IOException)
      {
      }

      if (serial_->isOpen())
      {
        connected_ = true;
        return;
      } else
      {
        connected_ = false;
        ROS_INFO("Bad Connection with serial port Error %s", port_);
      }
    }

    ROS_INFO("Motor controller not responding.");
  }

  void WMRoboteqHardwareInterface::read()
  {
//    ROS_DEBUG_STREAM_NAMED("serial", "Bytes waiting: " << serial_->available());
//    std::string msg = serial_->readline(max_line_length, eol);
//    if (!msg.empty())
//    {
//      ROS_DEBUG_STREAM_NAMED("serial", "RX: " << msg);
//      if (msg[0] == '&')
//      {
//        receiving_script_messages_ = true;
//        // Message generated by the Microbasic script.
//        boost::trim(msg);
//        if (msg[1] == 's')
//        {
//          processStatus(msg);
//        } else if (msg[1] == 'f')
//        {
//          processFeedback(msg);
//        } else if (msg[1] == 'i')
//        {
//          processId(msg);
//        }
//      } else
//      {
//        // Unknown other message.
//        ROS_WARN_STREAM("Unknown serial message received: " << msg);
//      }
//    } else
//    {
//      ROS_WARN_NAMED("serial", "Serial::readline() returned no data.");
//      if (!receiving_script_messages_)
//      {
//        if (start_script_attempts_ < 5)
//        {
//          start_script_attempts_++;
//          ROS_DEBUG("Attempt #%d to start MBS program.", start_script_attempts_);
//          startScript();
//          flush();
//        }
//      } else
//      {
//        ROS_DEBUG("Script is believed to be in-place and running, so taking no action.");
//      }
//    }
  }

  void WMRoboteqHardwareInterface::write()
  {
//    // Reset command timeout.
//    timeout_timer_.stop();
//    timeout_timer_.start();
//
//    // Update mode of motor driver. We send this on each command for redundancy against a
//    // lost message, and the MBS script keeps track of changes and updates the control
//    // constants accordingly.
//    command_ << "VAR" << CHANNEL << static_cast<int>(MODE_VELOCITY) << send_;
//
//    // Get a -1000 .. 1000 command as a proportion of the maximum RPM.
//    int roboteq_velocity = to_rpm(joint_velocity_command_[0]) / MAX_RPM * 1000.0;
//    ROS_DEBUG_STREAM("Commanding " << roboteq_velocity << " velocity to motor driver.");
//
//    // Write mode and command to the motor driver.
//    command_ << "G" << CHANNEL << roboteq_velocity << send_;
//
//    flush();
  }

  void WMRoboteqHardwareInterface::timeoutCallback(const ros::TimerEvent &)
  {
    // Sends stop command repeatedly at 10Hz when not being otherwise commanded. Sending
    // repeatedly is a hedge against a lost serial message.
    ROS_DEBUG("Commanding motor to stop due to user command timeout.");
    command_ << "VAR" << CHANNEL << static_cast<int>(MODE_STOPPED) << send_;
    flush();
  }

  void WMRoboteqHardwareInterface::sendMessage(std::string msg)
  {
    tx_buffer_ << msg << eol;
  }

  void WMRoboteqHardwareInterface::flush()
  {
    ssize_t bytes_written = serial_->write(tx_buffer_.str());
    if (bytes_written < tx_buffer_.tellp())
    {
      ROS_WARN_STREAM("Serial write timeout, " << bytes_written << " bytes written of " << tx_buffer_.tellp() << ".");
    }
    tx_buffer_.str("");
  }

  void WMRoboteqHardwareInterface::processStatus(std::string str)
  {
    // Link to generated source from Microbasic script file.
    const int script_ver = 30;

    std::vector <std::string> fields;
    boost::split(fields, str, boost::algorithm::is_any_of(":"));
    try
    {
      int reported_script_ver = boost::lexical_cast<int>(fields[1]);
      static int wrong_script_version_count = 0;
      if (reported_script_ver == script_ver)
      {
        wrong_script_version_count = 0;
      } else
      {
        if (++wrong_script_version_count > 5)
        {
          ROS_WARN_STREAM("Script version mismatch. Expecting " << script_ver <<
                                                                " but controller consistently reports "
                                                                << reported_script_ver << ". " <<
                                                                ". Now attempting download.");
        }
        return;
      }

      if (fields.size() != 7)
      {
        ROS_WARN("Wrong number of status fields. Dropping message.");
        return;
      }
    } catch (std::bad_cast &e)
    {
      ROS_WARN("Failure parsing status data. Dropping message.");
      return;
    }
  }

  void WMRoboteqHardwareInterface::processFeedback(std::string msg)
  {
    std::vector <std::string> fields;
    boost::split(fields, msg, boost::algorithm::is_any_of(":"));
    if (fields.size() != 11)
    {
      ROS_WARN("Wrong number of feedback fields. Dropping message.");
      return;
    }
    // Scale factors as outlined in the relevant portions of the user manual, please
    // see mbs/script.mbs for URL and specific page references.
    try
    {
      joint_velocity_[0] = from_rpm(boost::lexical_cast<double>(fields[5]));
      joint_position_[0] = from_encoder_ticks(boost::lexical_cast<double>(fields[6]));
    }
    catch (std::bad_cast &e)
    {
      ROS_WARN("Failure parsing feedback data. Dropping message.");
      return;
    }
  }

  void WMRoboteqHardwareInterface::processId(std::string str)
  {
    if (!idSet_)
    {
      std::vector <std::string> fields;
      int id;
      boost::split(fields, str, boost::algorithm::is_any_of(":"));
      if (fields.size() != 3)
      {
        ROS_WARN("ProcessId: Wrong number of feedback fields. Dropping message.");
        return;
      }

      try
      {
        id = boost::lexical_cast<int>(fields[2]);
      } catch (std::bad_cast &e)
      {
        ROS_WARN("Failure parsing id channel number. Dropping message.");
        return;
      }

      device_id_ = id;
      idSet_ = true;
    }
    return;
  }

  void WMRoboteqHardwareInterface::getId()
  {

    bool idSet = false;

    while (!idSet)
    {

      ROS_DEBUG_STREAM_NAMED("serial", "Bytes waiting: " << serial_->available());
      std::string msg = serial_->readline(max_line_length, eol);
      if (!msg.empty())
      {
        if (msg[0] == '&')
        {
          receiving_script_messages_ = true;
          // Message generated by the Microbasic script.
          boost::trim(msg);
          if (msg[1] == 'i')
          {
            setID(msg);
            idSet = true;
          }
        }
      }
    }
  }

  void WMRoboteqHardwareInterface::setID(std::string str)
  {
    std::vector <std::string> fields;
    boost::split(fields, str, boost::algorithm::is_any_of(":"));
    if (fields.size() != 3)
    {
      ROS_WARN("setID: Wrong number of fields, must be 3. Dropping message.");
      return;
    }

    try
    {
      device_id_ = boost::lexical_cast<int>(fields[2]);
    } catch (std::bad_cast &e)
    {
      ROS_WARN("Failure parsing id channel number. Dropping message.");
      return;
    }
    return;
  }

}

PLUGINLIB_EXPORT_CLASS( WMRoboteq::WMRoboteqHardwareInterface, hardware_interface::RobotHW)